"""
Network Scanner Module
Handles port scanning, service detection, and network reconnaissance
"""

import nmap
import socket
import threading
from concurrent.futures import ThreadPoolExecutor, as_completed
import dns.resolver
import time
from typing import Dict, List, Any
import subprocess
import platform

class NetworkScanner:
    """Network scanning and reconnaissance class"""
    
    def __init__(self):
        self.nm = nmap.PortScanner()
        self.results = {}
    
    def scan_target(self, target: str, port_range: str = "1-1000") -> Dict[str, Any]:
        """
        Perform comprehensive network scan of target
        
        Args:
            target: Target IP address or domain
            port_range: Port range to scan (e.g., "1-1000")
            
        Returns:
            Dictionary containing scan results
        """
        results = {
            'target': target,
            'scan_time': time.strftime('%Y-%m-%d %H:%M:%S'),
            'open_ports': [],
            'services': {},
            'os_detection': {},
            'dns_info': {},
            'ping_result': False
        }
        
        try:
            # Resolve domain to IP if necessary
            resolved_ip = self._resolve_target(target)
            results['resolved_ip'] = resolved_ip
            
            # Ping test
            results['ping_result'] = self._ping_host(resolved_ip)
            
            # Port scan
            print(f"Scanning ports {port_range} on {target}...")
            self.nm.scan(resolved_ip, port_range, arguments='-sS -O -sV --version-intensity 5')
            
            if resolved_ip in self.nm.all_hosts():
                host_info = self.nm[resolved_ip]
                
                # Extract open ports and services
                for protocol in host_info.all_protocols():
                    ports = host_info[protocol].keys()
                    for port in ports:
                        port_info = host_info[protocol][port]
                        if port_info['state'] == 'open':
                            results['open_ports'].append(port)
                            results['services'][port] = {
                                'service': port_info.get('name', 'unknown'),
                                'version': port_info.get('version', ''),
                                'product': port_info.get('product', ''),
                                'extrainfo': port_info.get('extrainfo', '')
                            }
                
                # OS Detection
                if 'osmatch' in host_info:
                    results['os_detection'] = {
                        'matches': [match for match in host_info['osmatch']],
                        'fingerprint': host_info.get('fingerprint', '')
                    }
            
            # DNS enumeration
            results['dns_info'] = self._dns_enumeration(target)
            
            # Additional scans
            results['ssl_info'] = self._scan_ssl_ports(resolved_ip, results['open_ports'])
            results['vulnerability_hints'] = self._check_vulnerability_hints(results)
            
        except Exception as e:
            results['error'] = str(e)
            print(f"Error during network scan: {e}")
        
        return results
    
    def _resolve_target(self, target: str) -> str:
        """Resolve domain name to IP address"""
        try:
            return socket.gethostbyname(target)
        except socket.gaierror:
            return target
    
    def _ping_host(self, host: str) -> bool:
        """Ping host to check if it's alive"""
        try:
            param = '-n' if platform.system().lower() == 'windows' else '-c'
            result = subprocess.run(
                ['ping', param, '1', host],
                capture_output=True,
                timeout=5
            )
            return result.returncode == 0
        except:
            return False
    
    def _dns_enumeration(self, target: str) -> Dict[str, Any]:
        """Perform DNS enumeration"""
        dns_info = {
            'a_records': [],
            'mx_records': [],
            'ns_records': [],
            'txt_records': [],
            'subdomains': []
        }
        
        try:
            # A records
            answers = dns.resolver.resolve(target, 'A')
            dns_info['a_records'] = [str(rdata) for rdata in answers]
        except:
            pass
        
        try:
            # MX records
            answers = dns.resolver.resolve(target, 'MX')
            dns_info['mx_records'] = [str(rdata) for rdata in answers]
        except:
            pass
        
        try:
            # NS records
            answers = dns.resolver.resolve(target, 'NS')
            dns_info['ns_records'] = [str(rdata) for rdata in answers]
        except:
            pass
        
        try:
            # TXT records
            answers = dns.resolver.resolve(target, 'TXT')
            dns_info['txt_records'] = [str(rdata) for rdata in answers]
        except:
            pass
        
        # Basic subdomain enumeration
        dns_info['subdomains'] = self._enumerate_subdomains(target)
        
        return dns_info
    
    def _enumerate_subdomains(self, target: str) -> List[str]:
        """Basic subdomain enumeration"""
        common_subdomains = [
            'www', 'mail', 'ftp', 'admin', 'test', 'dev', 'staging', 
            'api', 'blog', 'shop', 'store', 'support', 'help'
        ]
        
        found_subdomains = []
        
        def check_subdomain(subdomain):
            try:
                full_domain = f"{subdomain}.{target}"
                socket.gethostbyname(full_domain)
                return full_domain
            except:
                return None
        
        with ThreadPoolExecutor(max_workers=10) as executor:
            future_to_subdomain = {
                executor.submit(check_subdomain, sub): sub 
                for sub in common_subdomains
            }
            
            for future in as_completed(future_to_subdomain):
                result = future.result()
                if result:
                    found_subdomains.append(result)
        
        return found_subdomains
    
    def _scan_ssl_ports(self, target: str, open_ports: List[int]) -> Dict[str, Any]:
        """Scan SSL/TLS enabled ports for certificate information"""
        ssl_info = {}
        ssl_ports = [port for port in open_ports if port in [443, 993, 995, 465, 587, 636]]
        
        for port in ssl_ports:
            try:
                import ssl
                context = ssl.create_default_context()
                with socket.create_connection((target, port), timeout=5) as sock:
                    with context.wrap_socket(sock, server_hostname=target) as ssock:
                        cert = ssock.getpeercert()
                        ssl_info[port] = {
                            'subject': dict(x[0] for x in cert['subject']),
                            'issuer': dict(x[0] for x in cert['issuer']),
                            'version': cert['version'],
                            'serial_number': cert['serialNumber'],
                            'not_before': cert['notBefore'],
                            'not_after': cert['notAfter']
                        }
            except Exception as e:
                ssl_info[port] = {'error': str(e)}
        
        return ssl_info
    
    def _check_vulnerability_hints(self, results: Dict[str, Any]) -> List[Dict[str, str]]:
        """Check for potential vulnerability indicators"""
        hints = []
        
        # Check for common vulnerable services
        vulnerable_services = {
            'ftp': [21],
            'telnet': [23],
            'smtp': [25],
            'http': [80, 8080],
            'pop3': [110],
            'imap': [143],
            'snmp': [161],
            'https': [443, 8443],
            'smb': [445],
            'ssh': [22]
        }
        
        for service, ports in vulnerable_services.items():
            for port in ports:
                if port in results['open_ports']:
                    service_info = results['services'].get(port, {})
                    product = service_info.get('product', '').lower()
                    version = service_info.get('version', '').lower()
                    
                    # Check for known vulnerable versions
                    if service == 'ssh' and 'openssh' in product:
                        hints.append({
                            'port': str(port),
                            'service': service,
                            'type': 'info',
                            'description': 'SSH service detected - check for weak authentication'
                        })
                    
                    elif service in ['http', 'https']:
                        hints.append({
                            'port': str(port),
                            'service': service,
                            'type': 'info',
                            'description': 'Web service detected - requires web application testing'
                        })
                    
                    elif service == 'ftp':
                        hints.append({
                            'port': str(port),
                            'service': service,
                            'type': 'warning',
                            'description': 'FTP service detected - check for anonymous access'
                        })
                    
                    elif service == 'telnet':
                        hints.append({
                            'port': str(port),
                            'service': service,
                            'type': 'high',
                            'description': 'Telnet service detected - unencrypted protocol'
                        })
        
        return hints