"""
Web Application Scanner Module
Handles web application vulnerability testing and analysis
"""

import requests
from bs4 import BeautifulSoup
import urllib.parse
from urllib.robotparser import RobotFileParser
import re
import time
from typing import Dict, List, Any, Set
import threading
from concurrent.futures import ThreadPoolExecutor, as_completed
import json
import ssl
import socket

class WebAppScanner:
    """Web application vulnerability scanner"""
    
    def __init__(self):
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        })
        self.timeout = 10
        
    def scan_webapp(self, target: str, ports: List[int]) -> Dict[str, Any]:
        """
        Scan web applications on specified ports
        
        Args:
            target: Target domain or IP
            ports: List of HTTP/HTTPS ports to scan
            
        Returns:
            Dictionary containing web app scan results
        """
        results = {
            'target': target,
            'scan_time': time.strftime('%Y-%m-%d %H:%M:%S'),
            'applications': {}
        }
        
        for port in ports:
            try:
                # Determine protocol
                protocol = 'https' if port in [443, 8443] else 'http'
                base_url = f"{protocol}://{target}:{port}"
                
                print(f"Scanning web application at {base_url}")
                app_results = self.comprehensive_scan(base_url)
                results['applications'][f"{protocol}_{port}"] = app_results
                
            except Exception as e:
                results['applications'][f"port_{port}"] = {'error': str(e)}
        
        return results
    
    def comprehensive_scan(self, base_url: str) -> Dict[str, Any]:
        """Perform comprehensive web application scan"""
        results = {
            'base_url': base_url,
            'server_info': {},
            'directory_enum': [],
            'form_analysis': [],
            'sql_injection': [],
            'xss_vulnerabilities': [],
            'csrf_analysis': {},
            'ssl_analysis': {},
            'headers_analysis': {},
            'file_inclusion': [],
            'command_injection': [],
            'information_disclosure': [],
            'authentication_issues': []
        }
        
        try:
            # Basic server information
            results['server_info'] = self._get_server_info(base_url)
            
            # Security headers analysis
            results['headers_analysis'] = self._analyze_security_headers(base_url)
            
            # SSL/TLS analysis for HTTPS
            if base_url.startswith('https'):
                results['ssl_analysis'] = self._analyze_ssl(base_url)
            
            # Directory enumeration
            results['directory_enum'] = self._directory_enumeration(base_url)
            
            # Find and analyze forms
            forms = self._find_forms(base_url)
            results['form_analysis'] = forms
            
            # Test for various vulnerabilities
            if forms:
                results['sql_injection'] = self._test_sql_injection(base_url, forms)
                results['xss_vulnerabilities'] = self._test_xss(base_url, forms)
                results['csrf_analysis'] = self._test_csrf(base_url, forms)
            
            # Test for file inclusion vulnerabilities
            results['file_inclusion'] = self._test_file_inclusion(base_url)
            
            # Test for command injection
            results['command_injection'] = self._test_command_injection(base_url)
            
            # Information disclosure tests
            results['information_disclosure'] = self._test_information_disclosure(base_url)
            
            # Authentication bypass tests
            results['authentication_issues'] = self._test_authentication_issues(base_url)
            
        except Exception as e:
            results['error'] = str(e)
        
        return results
    
    def _get_server_info(self, url: str) -> Dict[str, Any]:
        """Get basic server information"""
        info = {}
        try:
            response = self.session.get(url, timeout=self.timeout, verify=False)
            info['status_code'] = response.status_code
            info['server'] = response.headers.get('Server', 'Unknown')
            info['powered_by'] = response.headers.get('X-Powered-By', 'Unknown')
            info['content_type'] = response.headers.get('Content-Type', 'Unknown')
            info['content_length'] = response.headers.get('Content-Length', 'Unknown')
            
            # Technology detection
            info['technologies'] = self._detect_technologies(response)
            
        except Exception as e:
            info['error'] = str(e)
        
        return info
    
    def _detect_technologies(self, response) -> List[str]:
        """Detect web technologies from response"""
        technologies = []
        headers = response.headers
        content = response.text.lower()
        
        # Server detection
        server = headers.get('Server', '').lower()
        if 'apache' in server:
            technologies.append('Apache')
        elif 'nginx' in server:
            technologies.append('Nginx')
        elif 'iis' in server:
            technologies.append('IIS')
        
        # Framework detection
        if 'laravel' in content or 'laravel_session' in content:
            technologies.append('Laravel')
        elif 'django' in content or 'csrfmiddlewaretoken' in content:
            technologies.append('Django')
        elif 'rails' in content or 'authenticity_token' in content:
            technologies.append('Ruby on Rails')
        elif 'wp-content' in content or 'wordpress' in content:
            technologies.append('WordPress')
        elif 'joomla' in content:
            technologies.append('Joomla')
        elif 'drupal' in content:
            technologies.append('Drupal')
        
        # JavaScript frameworks
        if 'react' in content:
            technologies.append('React')
        elif 'angular' in content:
            technologies.append('Angular')
        elif 'vue' in content:
            technologies.append('Vue.js')
        
        return technologies
    
    def _analyze_security_headers(self, url: str) -> Dict[str, Any]:
        """Analyze security headers"""
        analysis = {'missing_headers': [], 'present_headers': {}, 'recommendations': []}
        
        try:
            response = self.session.get(url, timeout=self.timeout, verify=False)
            headers = response.headers
            
            # Important security headers to check
            security_headers = {
                'X-Frame-Options': 'Prevents clickjacking attacks',
                'X-XSS-Protection': 'Enables XSS filtering',
                'X-Content-Type-Options': 'Prevents MIME type sniffing',
                'Strict-Transport-Security': 'Enforces HTTPS connections',
                'Content-Security-Policy': 'Prevents various injection attacks',
                'Referrer-Policy': 'Controls referrer information',
                'Permissions-Policy': 'Controls browser features'
            }
            
            for header, description in security_headers.items():
                if header in headers:
                    analysis['present_headers'][header] = {
                        'value': headers[header],
                        'description': description
                    }
                else:
                    analysis['missing_headers'].append({
                        'header': header,
                        'description': description,
                        'severity': 'medium'
                    })
            
            # Check for information disclosure headers
            disclosure_headers = ['Server', 'X-Powered-By', 'X-AspNet-Version']
            for header in disclosure_headers:
                if header in headers:
                    analysis['recommendations'].append({
                        'type': 'information_disclosure',
                        'header': header,
                        'value': headers[header],
                        'recommendation': f'Consider removing {header} header to reduce information disclosure'
                    })
            
        except Exception as e:
            analysis['error'] = str(e)
        
        return analysis
    
    def _analyze_ssl(self, url: str) -> Dict[str, Any]:
        """Analyze SSL/TLS configuration"""
        analysis = {}
        
        try:
            hostname = urllib.parse.urlparse(url).hostname
            port = urllib.parse.urlparse(url).port or 443
            
            context = ssl.create_default_context()
            with socket.create_connection((hostname, port), timeout=self.timeout) as sock:
                with context.wrap_socket(sock, server_hostname=hostname) as ssock:
                    cert = ssock.getpeercert()
                    cipher = ssock.cipher()
                    
                    analysis['certificate'] = {
                        'subject': dict(x[0] for x in cert['subject']),
                        'issuer': dict(x[0] for x in cert['issuer']),
                        'version': cert['version'],
                        'serial_number': cert['serialNumber'],
                        'not_before': cert['notBefore'],
                        'not_after': cert['notAfter']
                    }
                    
                    analysis['cipher_suite'] = {
                        'name': cipher[0],
                        'version': cipher[1],
                        'bits': cipher[2]
                    }
                    
                    # Check for weak ciphers
                    weak_ciphers = ['RC4', 'DES', '3DES', 'MD5']
                    if any(weak in cipher[0] for weak in weak_ciphers):
                        analysis['warnings'] = ['Weak cipher suite detected']
        
        except Exception as e:
            analysis['error'] = str(e)
        
        return analysis
    
    def _directory_enumeration(self, base_url: str) -> List[Dict[str, Any]]:
        """Enumerate common directories and files"""
        common_paths = [
            'admin', 'administrator', 'login', 'wp-admin', 'phpmyadmin',
            'backup', 'config', 'test', 'dev', 'staging', 'api',
            'robots.txt', 'sitemap.xml', '.git', '.env', 'config.php',
            'wp-config.php', 'database.sql', 'backup.sql'
        ]
        
        found_paths = []
        
        def check_path(path):
            try:
                url = f"{base_url.rstrip('/')}/{path}"
                response = self.session.get(url, timeout=self.timeout, verify=False)
                if response.status_code == 200:
                    return {
                        'path': path,
                        'url': url,
                        'status_code': response.status_code,
                        'content_length': len(response.content),
                        'content_type': response.headers.get('Content-Type', 'unknown')
                    }
                elif response.status_code in [301, 302]:
                    return {
                        'path': path,
                        'url': url,
                        'status_code': response.status_code,
                        'redirect_to': response.headers.get('Location', ''),
                        'type': 'redirect'
                    }
            except:
                pass
            return None
        
        with ThreadPoolExecutor(max_workers=10) as executor:
            future_to_path = {executor.submit(check_path, path): path for path in common_paths}
            
            for future in as_completed(future_to_path):
                result = future.result()
                if result:
                    found_paths.append(result)
        
        return found_paths
    
    def _find_forms(self, url: str) -> List[Dict[str, Any]]:
        """Find and analyze forms on the webpage"""
        forms = []
        
        try:
            response = self.session.get(url, timeout=self.timeout, verify=False)
            soup = BeautifulSoup(response.text, 'html.parser')
            
            for form in soup.find_all('form'):
                form_data = {
                    'action': form.get('action', ''),
                    'method': form.get('method', 'get').lower(),
                    'inputs': []
                }
                
                # Get all input fields
                for inp in form.find_all(['input', 'textarea', 'select']):
                    input_data = {
                        'name': inp.get('name', ''),
                        'type': inp.get('type', 'text'),
                        'value': inp.get('value', '')
                    }
                    form_data['inputs'].append(input_data)
                
                forms.append(form_data)
        
        except Exception as e:
            pass
        
        return forms
    
    def _test_sql_injection(self, base_url: str, forms: List[Dict]) -> List[Dict[str, Any]]:
        """Test for SQL injection vulnerabilities"""
        vulnerabilities = []
        
        # SQL injection payloads
        sqli_payloads = [
            "' OR '1'='1",
            "' OR 1=1--",
            "' UNION SELECT 1,2,3--",
            "'; DROP TABLE users;--",
            "' AND 1=2 UNION SELECT 1,2,3--"
        ]
        
        # Error patterns that indicate SQL injection
        error_patterns = [
            r"sql syntax",
            r"mysql_fetch",
            r"ora-\d{5}",
            r"microsoft odbc",
            r"sqlite3",
            r"postgresql"
        ]
        
        for form in forms:
            if not form['inputs']:
                continue
                
            for payload in sqli_payloads:
                try:
                    form_data = {}
                    vulnerable_param = None
                    
                    # Fill form with normal data and one field with payload
                    for inp in form['inputs']:
                        if inp['type'] in ['text', 'email', 'search']:
                            if not vulnerable_param:
                                form_data[inp['name']] = payload
                                vulnerable_param = inp['name']
                            else:
                                form_data[inp['name']] = 'test'
                        elif inp['type'] == 'password':
                            form_data[inp['name']] = 'password'
                    
                    if not form_data:
                        continue
                    
                    # Submit form
                    action_url = urllib.parse.urljoin(base_url, form['action'])
                    
                    if form['method'] == 'post':
                        response = self.session.post(action_url, data=form_data, timeout=self.timeout, verify=False)
                    else:
                        response = self.session.get(action_url, params=form_data, timeout=self.timeout, verify=False)
                    
                    # Check for SQL error patterns
                    for pattern in error_patterns:
                        if re.search(pattern, response.text, re.IGNORECASE):
                            vulnerabilities.append({
                                'form_action': form['action'],
                                'method': form['method'],
                                'vulnerable_parameter': vulnerable_param,
                                'payload': payload,
                                'type': 'sql_injection',
                                'severity': 'high',
                                'evidence': f"SQL error pattern found: {pattern}"
                            })
                            break
                
                except Exception:
                    continue
        
        return vulnerabilities
    
    def _test_xss(self, base_url: str, forms: List[Dict]) -> List[Dict[str, Any]]:
        """Test for Cross-Site Scripting vulnerabilities"""
        vulnerabilities = []
        
        # XSS payloads
        xss_payloads = [
            "<script>alert('XSS')</script>",
            "javascript:alert('XSS')",
            "<img src=x onerror=alert('XSS')>",
            "'\"><script>alert('XSS')</script>",
            "<svg onload=alert('XSS')>"
        ]
        
        for form in forms:
            if not form['inputs']:
                continue
                
            for payload in xss_payloads:
                try:
                    form_data = {}
                    vulnerable_param = None
                    
                    # Fill form with XSS payload
                    for inp in form['inputs']:
                        if inp['type'] in ['text', 'email', 'search', 'textarea']:
                            if not vulnerable_param:
                                form_data[inp['name']] = payload
                                vulnerable_param = inp['name']
                            else:
                                form_data[inp['name']] = 'test'
                        elif inp['type'] == 'password':
                            form_data[inp['name']] = 'password'
                    
                    if not form_data:
                        continue
                    
                    # Submit form
                    action_url = urllib.parse.urljoin(base_url, form['action'])
                    
                    if form['method'] == 'post':
                        response = self.session.post(action_url, data=form_data, timeout=self.timeout, verify=False)
                    else:
                        response = self.session.get(action_url, params=form_data, timeout=self.timeout, verify=False)
                    
                    # Check if payload is reflected in response
                    if payload in response.text:
                        vulnerabilities.append({
                            'form_action': form['action'],
                            'method': form['method'],
                            'vulnerable_parameter': vulnerable_param,
                            'payload': payload,
                            'type': 'xss',
                            'severity': 'medium',
                            'evidence': 'Payload reflected in response'
                        })
                
                except Exception:
                    continue
        
        return vulnerabilities
    
    def _test_csrf(self, base_url: str, forms: List[Dict]) -> Dict[str, Any]:
        """Test for CSRF vulnerabilities"""
        csrf_analysis = {
            'forms_without_csrf': [],
            'csrf_tokens_found': [],
            'recommendations': []
        }
        
        for form in forms:
            has_csrf_token = False
            csrf_fields = ['csrf_token', 'authenticity_token', '_token', 'csrfmiddlewaretoken']
            
            for inp in form['inputs']:
                if inp['name'].lower() in csrf_fields or 'csrf' in inp['name'].lower():
                    has_csrf_token = True
                    csrf_analysis['csrf_tokens_found'].append({
                        'form_action': form['action'],
                        'token_field': inp['name']
                    })
                    break
            
            if not has_csrf_token and form['method'] == 'post':
                csrf_analysis['forms_without_csrf'].append({
                    'form_action': form['action'],
                    'method': form['method'],
                    'severity': 'medium',
                    'description': 'POST form without CSRF protection'
                })
        
        if csrf_analysis['forms_without_csrf']:
            csrf_analysis['recommendations'].append(
                'Implement CSRF tokens for all state-changing operations'
            )
        
        return csrf_analysis
    
    def _test_file_inclusion(self, base_url: str) -> List[Dict[str, Any]]:
        """Test for Local/Remote File Inclusion vulnerabilities"""
        vulnerabilities = []
        
        # Common parameters that might be vulnerable
        test_params = ['file', 'page', 'include', 'path', 'doc', 'template']
        
        # LFI payloads
        lfi_payloads = [
            '../../../etc/passwd',
            '..\\..\\..\\windows\\system32\\drivers\\etc\\hosts',
            'php://filter/read=convert.base64-encode/resource=index.php'
        ]
        
        for param in test_params:
            for payload in lfi_payloads:
                try:
                    test_url = f"{base_url}?{param}={payload}"
                    response = self.session.get(test_url, timeout=self.timeout, verify=False)
                    
                    # Check for file inclusion indicators
                    if ('root:' in response.text and '/bin/' in response.text) or \
                       ('localhost' in response.text and '127.0.0.1' in response.text):
                        vulnerabilities.append({
                            'parameter': param,
                            'payload': payload,
                            'type': 'file_inclusion',
                            'severity': 'high',
                            'url': test_url,
                            'evidence': 'System file content detected in response'
                        })
                
                except Exception:
                    continue
        
        return vulnerabilities
    
    def _test_command_injection(self, base_url: str) -> List[Dict[str, Any]]:
        """Test for command injection vulnerabilities"""
        vulnerabilities = []
        
        # Command injection payloads
        cmd_payloads = [
            '; ls -la',
            '| dir',
            '`whoami`',
            '$(id)',
            '; cat /etc/passwd'
        ]
        
        # Common parameters that might be vulnerable
        test_params = ['cmd', 'command', 'exec', 'ping', 'host', 'ip']
        
        for param in test_params:
            for payload in cmd_payloads:
                try:
                    test_url = f"{base_url}?{param}=test{payload}"
                    response = self.session.get(test_url, timeout=self.timeout, verify=False)
                    
                    # Check for command execution indicators
                    if any(indicator in response.text.lower() for indicator in 
                           ['uid=', 'gid=', 'total ', 'volume in drive', 'directory of']):
                        vulnerabilities.append({
                            'parameter': param,
                            'payload': payload,
                            'type': 'command_injection',
                            'severity': 'critical',
                            'url': test_url,
                            'evidence': 'Command execution output detected'
                        })
                
                except Exception:
                    continue
        
        return vulnerabilities
    
    def _test_information_disclosure(self, base_url: str) -> List[Dict[str, Any]]:
        """Test for information disclosure vulnerabilities"""
        disclosures = []
        
        # Common files that might disclose information
        test_files = [
            '.env',
            'config.php',
            'wp-config.php',
            '.git/config',
            'phpinfo.php',
            'info.php',
            '.htaccess',
            'web.config',
            'composer.json',
            'package.json'
        ]
        
        for file_path in test_files:
            try:
                test_url = f"{base_url.rstrip('/')}/{file_path}"
                response = self.session.get(test_url, timeout=self.timeout, verify=False)
                
                if response.status_code == 200:
                    # Check for sensitive information patterns
                    sensitive_patterns = [
                        (r'password\s*=\s*["\']([^"\']+)["\']', 'Password'),
                        (r'api[_-]?key\s*=\s*["\']([^"\']+)["\']', 'API Key'),
                        (r'secret\s*=\s*["\']([^"\']+)["\']', 'Secret'),
                        (r'database\s*=\s*["\']([^"\']+)["\']', 'Database'),
                        (r'DB_PASSWORD\s*=\s*([^\n\r]+)', 'Database Password')
                    ]
                    
                    for pattern, desc in sensitive_patterns:
                        matches = re.findall(pattern, response.text, re.IGNORECASE)
                        if matches:
                            disclosures.append({
                                'file': file_path,
                                'url': test_url,
                                'type': 'information_disclosure',
                                'severity': 'high',
                                'description': f'{desc} found in {file_path}',
                                'evidence': f'Pattern: {pattern}'
                            })
            
            except Exception:
                continue
        
        return disclosures
    
    def _test_authentication_issues(self, base_url: str) -> List[Dict[str, Any]]:
        """Test for authentication and authorization issues"""
        issues = []
        
        # Test for common admin panels
        admin_paths = [
            'admin',
            'administrator',
            'wp-admin',
            'admin.php',
            'login.php',
            'admin/login',
            'management'
        ]
        
        for path in admin_paths:
            try:
                test_url = f"{base_url.rstrip('/')}/{path}"
                response = self.session.get(test_url, timeout=self.timeout, verify=False)
                
                if response.status_code == 200:
                    # Check for default credentials forms
                    if 'login' in response.text.lower() and 'password' in response.text.lower():
                        issues.append({
                            'path': path,
                            'url': test_url,
                            'type': 'authentication',
                            'severity': 'medium',
                            'description': 'Admin login panel accessible',
                            'recommendation': 'Ensure strong authentication and consider IP restrictions'
                        })
                        
                        # Test for default credentials
                        default_creds = [
                            ('admin', 'admin'),
                            ('admin', 'password'),
                            ('admin', '123456'),
                            ('root', 'root'),
                            ('administrator', 'administrator')
                        ]
                        
                        # This would require form parsing and submission
                        # Simplified version here
                        issues.append({
                            'path': path,
                            'url': test_url,
                            'type': 'weak_authentication',
                            'severity': 'info',
                            'description': 'Consider testing for default credentials',
                            'recommendation': 'Test common username/password combinations'
                        })
            
            except Exception:
                continue
        
        return issues