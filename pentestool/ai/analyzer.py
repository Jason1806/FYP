"""
AI/ML Vulnerability Analyzer Module
Uses machine learning to analyze and prioritize vulnerabilities
"""

import numpy as np
import pandas as pd
from sklearn.ensemble import RandomForestClassifier
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report
import pickle
import os
import json
from typing import Dict, List, Any, Tuple
import nltk
from nltk.corpus import stopwords
from nltk.tokenize import word_tokenize
from nltk.stem import WordNetLemmatizer
import re

# Download required NLTK data (handled gracefully)
try:
    nltk.data.find('tokenizers/punkt')
except LookupError:
    nltk.download('punkt', quiet=True)

try:
    nltk.data.find('corpora/stopwords')
except LookupError:
    nltk.download('stopwords', quiet=True)

try:
    nltk.data.find('corpora/wordnet')
except LookupError:
    nltk.download('wordnet', quiet=True)

class VulnerabilityAnalyzer:
    """AI-powered vulnerability analysis and prioritization"""
    
    def __init__(self):
        self.vectorizer = TfidfVectorizer(max_features=1000, stop_words='english')
        self.severity_model = None
        self.exploitability_model = None
        self.lemmatizer = WordNetLemmatizer()
        self.stop_words = set(stopwords.words('english'))
        
        # Initialize or load pre-trained models
        self._load_or_create_models()
        
        # Vulnerability knowledge base
        self.vuln_kb = self._load_vulnerability_knowledge_base()
    
    def analyze_vulnerabilities(self, network_results: Dict, webapp_results: Dict) -> Dict[str, Any]:
        """
        Perform AI-powered vulnerability analysis
        
        Args:
            network_results: Results from network scanning
            webapp_results: Results from web application scanning
            
        Returns:
            Dictionary containing AI analysis results
        """
        analysis = {
            'vulnerability_summary': {},
            'risk_assessment': {},
            'prioritized_vulnerabilities': [],
            'attack_vectors': [],
            'remediation_suggestions': [],
            'business_impact': {},
            'simplified_explanations': {}
        }
        
        try:
            # Extract and normalize vulnerabilities
            vulnerabilities = self._extract_vulnerabilities(network_results, webapp_results)
            
            # Severity scoring using ML
            analysis['vulnerability_summary'] = self._analyze_vulnerability_severity(vulnerabilities)
            
            # Risk assessment
            analysis['risk_assessment'] = self._calculate_risk_score(vulnerabilities, network_results, webapp_results)
            
            # Prioritize vulnerabilities
            analysis['prioritized_vulnerabilities'] = self._prioritize_vulnerabilities(vulnerabilities)
            
            # Identify attack vectors
            analysis['attack_vectors'] = self._identify_attack_vectors(vulnerabilities, network_results, webapp_results)
            
            # Generate remediation suggestions
            analysis['remediation_suggestions'] = self._generate_remediation_suggestions(vulnerabilities)
            
            # Business impact assessment
            analysis['business_impact'] = self._assess_business_impact(vulnerabilities)
            
            # Generate simplified explanations
            analysis['simplified_explanations'] = self._generate_simple_explanations(vulnerabilities)
            
        except Exception as e:
            analysis['error'] = str(e)
        
        return analysis
    
    def _load_or_create_models(self):
        """Load pre-trained models or create new ones if they don't exist"""
        model_dir = os.path.join(os.path.dirname(__file__), '..', 'models')
        os.makedirs(model_dir, exist_ok=True)
        
        severity_model_path = os.path.join(model_dir, 'severity_model.pkl')
        exploitability_model_path = os.path.join(model_dir, 'exploitability_model.pkl')
        
        if os.path.exists(severity_model_path) and os.path.exists(exploitability_model_path):
            try:
                with open(severity_model_path, 'rb') as f:
                    self.severity_model = pickle.load(f)
                with open(exploitability_model_path, 'rb') as f:
                    self.exploitability_model = pickle.load(f)
                return
            except:
                pass
        
        # Create and train new models with synthetic data
        self._create_and_train_models(model_dir)
    
    def _create_and_train_models(self, model_dir: str):
        """Create and train ML models for vulnerability analysis"""
        # Generate synthetic training data for vulnerability severity prediction
        training_data = self._generate_training_data()
        
        X = training_data['features']
        y_severity = training_data['severity']
        y_exploitability = training_data['exploitability']
        
        # Train severity classification model
        self.severity_model = RandomForestClassifier(n_estimators=100, random_state=42)
        self.severity_model.fit(X, y_severity)
        
        # Train exploitability classification model
        self.exploitability_model = RandomForestClassifier(n_estimators=100, random_state=42)
        self.exploitability_model.fit(X, y_exploitability)
        
        # Save models
        with open(os.path.join(model_dir, 'severity_model.pkl'), 'wb') as f:
            pickle.dump(self.severity_model, f)
        with open(os.path.join(model_dir, 'exploitability_model.pkl'), 'wb') as f:
            pickle.dump(self.exploitability_model, f)
    
    def _generate_training_data(self) -> Dict[str, Any]:
        """Generate synthetic training data for ML models"""
        # Simplified feature generation for demonstration
        # In a real implementation, this would use actual vulnerability data
        
        vulnerabilities = [
            # High severity, high exploitability
            ("SQL Injection in login form", [1, 1, 1, 0, 1], "critical", "high"),
            ("Remote Code Execution via file upload", [1, 1, 1, 1, 1], "critical", "high"),
            ("Cross-Site Scripting in search", [1, 0, 1, 0, 0], "high", "medium"),
            ("Command Injection in admin panel", [1, 1, 1, 1, 0], "critical", "high"),
            
            # Medium severity
            ("Missing CSRF protection", [0, 0, 1, 0, 0], "medium", "low"),
            ("Information disclosure via headers", [0, 0, 0, 0, 0], "low", "low"),
            ("Weak SSL/TLS configuration", [0, 0, 0, 0, 1], "medium", "low"),
            ("Directory listing enabled", [0, 0, 0, 0, 0], "low", "low"),
            
            # Low severity
            ("Missing security headers", [0, 0, 0, 0, 0], "low", "low"),
            ("Outdated software version", [0, 0, 0, 0, 0], "medium", "low"),
        ]
        
        features = []
        severity_labels = []
        exploitability_labels = []
        
        severity_map = {"low": 0, "medium": 1, "high": 2, "critical": 3}
        exploit_map = {"low": 0, "medium": 1, "high": 2}
        
        for desc, feature_vec, severity, exploitability in vulnerabilities:
            # Add some noise to create more training samples
            for _ in range(10):
                noise = np.random.normal(0, 0.1, len(feature_vec))
                noisy_features = np.array(feature_vec) + noise
                features.append(noisy_features)
                severity_labels.append(severity_map[severity])
                exploitability_labels.append(exploit_map[exploitability])
        
        return {
            'features': np.array(features),
            'severity': np.array(severity_labels),
            'exploitability': np.array(exploitability_labels)
        }
    
    def _extract_vulnerabilities(self, network_results: Dict, webapp_results: Dict) -> List[Dict[str, Any]]:
        """Extract and normalize vulnerabilities from scan results"""
        vulnerabilities = []
        
        # Extract network vulnerabilities
        if 'vulnerability_hints' in network_results:
            for hint in network_results['vulnerability_hints']:
                vuln = {
                    'type': 'network',
                    'category': hint.get('service', 'unknown'),
                    'description': hint.get('description', ''),
                    'severity': hint.get('type', 'info'),
                    'port': hint.get('port', ''),
                    'source': 'network_scan'
                }
                vulnerabilities.append(vuln)
        
        # Extract web application vulnerabilities
        if 'applications' in webapp_results:
            for app_name, app_data in webapp_results['applications'].items():
                if isinstance(app_data, dict):
                    # SQL Injection vulnerabilities
                    for sqli in app_data.get('sql_injection', []):
                        vuln = {
                            'type': 'webapp',
                            'category': 'sql_injection',
                            'description': f"SQL Injection in {sqli.get('vulnerable_parameter', 'unknown parameter')}",
                            'severity': sqli.get('severity', 'medium'),
                            'evidence': sqli.get('evidence', ''),
                            'source': 'webapp_scan'
                        }
                        vulnerabilities.append(vuln)
                    
                    # XSS vulnerabilities
                    for xss in app_data.get('xss_vulnerabilities', []):
                        vuln = {
                            'type': 'webapp',
                            'category': 'xss',
                            'description': f"Cross-Site Scripting in {xss.get('vulnerable_parameter', 'unknown parameter')}",
                            'severity': xss.get('severity', 'medium'),
                            'evidence': xss.get('evidence', ''),
                            'source': 'webapp_scan'
                        }
                        vulnerabilities.append(vuln)
                    
                    # File inclusion vulnerabilities
                    for fi in app_data.get('file_inclusion', []):
                        vuln = {
                            'type': 'webapp',
                            'category': 'file_inclusion',
                            'description': f"File Inclusion in {fi.get('parameter', 'unknown parameter')}",
                            'severity': fi.get('severity', 'high'),
                            'evidence': fi.get('evidence', ''),
                            'source': 'webapp_scan'
                        }
                        vulnerabilities.append(vuln)
                    
                    # Command injection vulnerabilities
                    for ci in app_data.get('command_injection', []):
                        vuln = {
                            'type': 'webapp',
                            'category': 'command_injection',
                            'description': f"Command Injection in {ci.get('parameter', 'unknown parameter')}",
                            'severity': ci.get('severity', 'critical'),
                            'evidence': ci.get('evidence', ''),
                            'source': 'webapp_scan'
                        }
                        vulnerabilities.append(vuln)
                    
                    # Security header issues
                    headers_analysis = app_data.get('headers_analysis', {})
                    for missing_header in headers_analysis.get('missing_headers', []):
                        vuln = {
                            'type': 'webapp',
                            'category': 'security_headers',
                            'description': f"Missing security header: {missing_header.get('header', 'unknown')}",
                            'severity': missing_header.get('severity', 'low'),
                            'evidence': missing_header.get('description', ''),
                            'source': 'webapp_scan'
                        }
                        vulnerabilities.append(vuln)
        
        return vulnerabilities
    
    def _analyze_vulnerability_severity(self, vulnerabilities: List[Dict]) -> Dict[str, Any]:
        """Analyze vulnerability severity using ML"""
        summary = {
            'total_vulnerabilities': len(vulnerabilities),
            'by_severity': {'critical': 0, 'high': 0, 'medium': 0, 'low': 0, 'info': 0},
            'by_category': {},
            'ml_predictions': []
        }
        
        for vuln in vulnerabilities:
            # Count by severity
            severity = vuln.get('severity', 'info')
            if severity in summary['by_severity']:
                summary['by_severity'][severity] += 1
            else:
                summary['by_severity']['info'] += 1
            
            # Count by category
            category = vuln.get('category', 'unknown')
            summary['by_category'][category] = summary['by_category'].get(category, 0) + 1
            
            # ML-based severity prediction (if models are available)
            if self.severity_model is not None:
                features = self._extract_vulnerability_features(vuln)
                predicted_severity = self.severity_model.predict([features])[0]
                predicted_exploitability = self.exploitability_model.predict([features])[0]
                
                severity_labels = ["low", "medium", "high", "critical"]
                exploit_labels = ["low", "medium", "high"]
                
                summary['ml_predictions'].append({
                    'description': vuln.get('description', ''),
                    'predicted_severity': severity_labels[predicted_severity],
                    'predicted_exploitability': exploit_labels[predicted_exploitability],
                    'original_severity': severity
                })
        
        return summary
    
    def _extract_vulnerability_features(self, vuln: Dict) -> List[float]:
        """Extract numerical features from vulnerability for ML prediction"""
        # Simple feature extraction for demonstration
        features = [0, 0, 0, 0, 0]  # [injection, auth, disclosure, network, crypto]
        
        description = vuln.get('description', '').lower()
        category = vuln.get('category', '').lower()
        
        # Feature 0: Injection vulnerabilities
        if any(term in description or term in category for term in ['injection', 'sqli', 'xss', 'command']):
            features[0] = 1
        
        # Feature 1: Authentication issues
        if any(term in description or term in category for term in ['auth', 'login', 'password', 'csrf']):
            features[1] = 1
        
        # Feature 2: Information disclosure
        if any(term in description or term in category for term in ['disclosure', 'information', 'header', 'error']):
            features[2] = 1
        
        # Feature 3: Network vulnerabilities
        if vuln.get('type') == 'network' or 'port' in description:
            features[3] = 1
        
        # Feature 4: Cryptographic issues
        if any(term in description or term in category for term in ['ssl', 'tls', 'crypto', 'certificate']):
            features[4] = 1
        
        return features
    
    def _calculate_risk_score(self, vulnerabilities: List[Dict], network_results: Dict, webapp_results: Dict) -> Dict[str, Any]:
        """Calculate overall risk score based on vulnerabilities and environment"""
        risk_factors = {
            'vulnerability_count': len(vulnerabilities),
            'critical_vulns': len([v for v in vulnerabilities if v.get('severity') == 'critical']),
            'high_vulns': len([v for v in vulnerabilities if v.get('severity') == 'high']),
            'open_ports': len(network_results.get('open_ports', [])),
            'web_services': len([p for p in network_results.get('open_ports', []) if p in [80, 443, 8080, 8443]]),
            'attack_surface': 0
        }
        
        # Calculate attack surface
        risk_factors['attack_surface'] = (
            risk_factors['open_ports'] * 0.1 +
            risk_factors['web_services'] * 0.3 +
            risk_factors['critical_vulns'] * 1.0 +
            risk_factors['high_vulns'] * 0.5
        )
        
        # Calculate overall risk score (0-100)
        risk_score = min(100, (
            risk_factors['critical_vulns'] * 25 +
            risk_factors['high_vulns'] * 15 +
            risk_factors['attack_surface'] * 2
        ))
        
        # Risk level classification
        if risk_score >= 80:
            risk_level = "Critical"
        elif risk_score >= 60:
            risk_level = "High"
        elif risk_score >= 40:
            risk_level = "Medium"
        elif risk_score >= 20:
            risk_level = "Low"
        else:
            risk_level = "Very Low"
        
        return {
            'risk_score': risk_score,
            'risk_level': risk_level,
            'risk_factors': risk_factors,
            'recommendations': self._get_risk_recommendations(risk_level, risk_factors)
        }
    
    def _get_risk_recommendations(self, risk_level: str, risk_factors: Dict) -> List[str]:
        """Get risk-based recommendations"""
        recommendations = []
        
        if risk_level in ["Critical", "High"]:
            recommendations.append("Immediate action required - critical vulnerabilities detected")
            if risk_factors['critical_vulns'] > 0:
                recommendations.append("Address critical vulnerabilities first")
        
        if risk_factors['web_services'] > 0:
            recommendations.append("Review web application security configuration")
        
        if risk_factors['open_ports'] > 10:
            recommendations.append("Consider reducing the number of exposed services")
        
        recommendations.append("Implement regular security monitoring and scanning")
        recommendations.append("Ensure all software is up to date")
        
        return recommendations
    
    def _prioritize_vulnerabilities(self, vulnerabilities: List[Dict]) -> List[Dict[str, Any]]:
        """Prioritize vulnerabilities based on severity and exploitability"""
        severity_weights = {'critical': 4, 'high': 3, 'medium': 2, 'low': 1, 'info': 0}
        category_weights = {
            'sql_injection': 1.0,
            'command_injection': 1.0,
            'file_inclusion': 0.9,
            'xss': 0.7,
            'csrf': 0.5,
            'security_headers': 0.3,
            'information_disclosure': 0.4
        }
        
        prioritized = []
        
        for vuln in vulnerabilities:
            severity_score = severity_weights.get(vuln.get('severity', 'info'), 0)
            category_score = category_weights.get(vuln.get('category', 'unknown'), 0.1)
            
            # Calculate priority score
            priority_score = severity_score * category_score
            
            prioritized.append({
                'vulnerability': vuln,
                'priority_score': priority_score,
                'priority_rank': 0  # Will be set after sorting
            })
        
        # Sort by priority score
        prioritized.sort(key=lambda x: x['priority_score'], reverse=True)
        
        # Assign ranks
        for i, item in enumerate(prioritized):
            item['priority_rank'] = i + 1
        
        return prioritized
    
    def _identify_attack_vectors(self, vulnerabilities: List[Dict], network_results: Dict, webapp_results: Dict) -> List[Dict[str, Any]]:
        """Identify potential attack vectors"""
        attack_vectors = []
        
        # Web-based attack vectors
        web_vulns = [v for v in vulnerabilities if v.get('type') == 'webapp']
        if web_vulns:
            attack_vectors.append({
                'vector': 'Web Application Attack',
                'description': 'Attacker could exploit web application vulnerabilities',
                'vulnerabilities': len(web_vulns),
                'likelihood': 'High' if any(v.get('severity') in ['critical', 'high'] for v in web_vulns) else 'Medium',
                'impact': 'High'
            })
        
        # Network-based attack vectors
        open_ports = network_results.get('open_ports', [])
        if open_ports:
            attack_vectors.append({
                'vector': 'Network Service Attack',
                'description': 'Attacker could target exposed network services',
                'services': len(open_ports),
                'likelihood': 'Medium',
                'impact': 'Medium to High'
            })
        
        # SSH brute force vector
        if 22 in open_ports:
            attack_vectors.append({
                'vector': 'SSH Brute Force',
                'description': 'Attacker could attempt SSH brute force attacks',
                'service': 'SSH (Port 22)',
                'likelihood': 'High',
                'impact': 'High'
            })
        
        return attack_vectors
    
    def _generate_remediation_suggestions(self, vulnerabilities: List[Dict]) -> List[Dict[str, Any]]:
        """Generate AI-powered remediation suggestions"""
        suggestions = []
        
        # Group vulnerabilities by category
        by_category = {}
        for vuln in vulnerabilities:
            category = vuln.get('category', 'unknown')
            if category not in by_category:
                by_category[category] = []
            by_category[category].append(vuln)
        
        # Generate category-specific suggestions
        for category, vulns in by_category.items():
            if category == 'sql_injection':
                suggestions.append({
                    'category': 'SQL Injection',
                    'priority': 'Critical',
                    'affected_items': len(vulns),
                    'remediation': [
                        'Use parameterized queries/prepared statements',
                        'Implement input validation and sanitization',
                        'Apply principle of least privilege to database accounts',
                        'Enable SQL query logging and monitoring'
                    ],
                    'technical_details': 'SQL injection occurs when user input is directly concatenated into SQL queries without proper sanitization.'
                })
            
            elif category == 'xss':
                suggestions.append({
                    'category': 'Cross-Site Scripting (XSS)',
                    'priority': 'High',
                    'affected_items': len(vulns),
                    'remediation': [
                        'Implement proper output encoding/escaping',
                        'Use Content Security Policy (CSP) headers',
                        'Validate and sanitize all user inputs',
                        'Use secure templating engines'
                    ],
                    'technical_details': 'XSS vulnerabilities allow attackers to inject malicious scripts into web pages viewed by other users.'
                })
            
            elif category == 'command_injection':
                suggestions.append({
                    'category': 'Command Injection',
                    'priority': 'Critical',
                    'affected_items': len(vulns),
                    'remediation': [
                        'Avoid using system commands with user input',
                        'Use safe APIs instead of shell commands',
                        'Implement strict input validation',
                        'Run applications with minimal privileges'
                    ],
                    'technical_details': 'Command injection allows attackers to execute arbitrary commands on the server.'
                })
            
            elif category == 'security_headers':
                suggestions.append({
                    'category': 'Security Headers',
                    'priority': 'Medium',
                    'affected_items': len(vulns),
                    'remediation': [
                        'Implement missing security headers',
                        'Configure Content Security Policy (CSP)',
                        'Add X-Frame-Options header',
                        'Enable HTTP Strict Transport Security (HSTS)'
                    ],
                    'technical_details': 'Security headers provide additional protection against various attacks.'
                })
        
        return suggestions
    
    def _assess_business_impact(self, vulnerabilities: List[Dict]) -> Dict[str, Any]:
        """Assess business impact of vulnerabilities"""
        impact_assessment = {
            'confidentiality_impact': 'Low',
            'integrity_impact': 'Low',
            'availability_impact': 'Low',
            'financial_impact': 'Low',
            'reputation_impact': 'Low',
            'compliance_impact': 'Low'
        }
        
        critical_vulns = [v for v in vulnerabilities if v.get('severity') == 'critical']
        high_vulns = [v for v in vulnerabilities if v.get('severity') == 'high']
        
        if critical_vulns:
            impact_assessment['confidentiality_impact'] = 'High'
            impact_assessment['integrity_impact'] = 'High'
            impact_assessment['financial_impact'] = 'High'
            impact_assessment['reputation_impact'] = 'High'
        elif high_vulns:
            impact_assessment['confidentiality_impact'] = 'Medium'
            impact_assessment['integrity_impact'] = 'Medium'
            impact_assessment['financial_impact'] = 'Medium'
        
        # Check for specific vulnerability types
        for vuln in vulnerabilities:
            category = vuln.get('category', '')
            if category in ['sql_injection', 'command_injection']:
                impact_assessment['confidentiality_impact'] = 'High'
                impact_assessment['integrity_impact'] = 'High'
            elif category == 'xss':
                impact_assessment['integrity_impact'] = 'Medium'
                impact_assessment['reputation_impact'] = 'Medium'
        
        return impact_assessment
    
    def _generate_simple_explanations(self, vulnerabilities: List[Dict]) -> Dict[str, str]:
        """Generate simplified explanations suitable for non-technical audiences"""
        explanations = {}
        
        # Create explanations for different vulnerability types
        explanations['sql_injection'] = """
        **What is SQL Injection?**
        Imagine your website's database is like a filing cabinet, and SQL injection is like someone tricking 
        the filing system into giving them access to files they shouldn't see. A hacker can type special 
        commands into your website's forms (like login boxes) that make the database reveal sensitive 
        information like passwords, credit card numbers, or customer data.
        
        **Why is this dangerous?**
        Hackers could steal all your customer information, delete important data, or even take control 
        of your entire website.
        
        **How to fix it:**
        Your developers need to add special filters that check what people type into forms before 
        sending it to the database - like having a security guard check everyone's ID before they 
        can access the filing cabinet.
        """
        
        explanations['xss'] = """
        **What is Cross-Site Scripting (XSS)?**
        Think of XSS like someone putting a fake sticker on a stop sign that makes cars think they 
        should speed up instead of stop. Hackers can inject malicious code into your website that 
        runs when other people visit it, potentially stealing their personal information or tricking 
        them into doing things they didn't intend to do.
        
        **Why is this dangerous?**
        Visitors to your website could have their passwords stolen, be redirected to malicious sites, 
        or unknowingly perform actions on your site.
        
        **How to fix it:**
        Your website needs to "clean" all user input before displaying it, like washing fruit before 
        eating it - removing any harmful code that might be hidden inside.
        """
        
        explanations['command_injection'] = """
        **What is Command Injection?**
        This is like giving someone access to your computer's control panel when they should only 
        be able to use a simple calculator. Hackers can trick your website into running dangerous 
        commands on your server, potentially taking complete control of your system.
        
        **Why is this dangerous?**
        This is one of the most serious vulnerabilities - hackers could steal all your data, 
        install malicious software, or completely destroy your website.
        
        **How to fix it:**
        Your developers need to strictly control what commands can be run and never allow user 
        input to directly control system commands - like having a security system that only 
        allows pre-approved actions.
        """
        
        explanations['security_headers'] = """
        **What are Missing Security Headers?**
        Security headers are like safety features in a car - seatbelts, airbags, and anti-lock brakes. 
        When they're missing from your website, it's like driving without these safety features. 
        Your site might work fine, but it's more vulnerable to various types of attacks.
        
        **Why is this important?**
        Without these security features, your website and its visitors are more vulnerable to 
        attacks like clickjacking (tricking users into clicking malicious links) and data theft.
        
        **How to fix it:**
        Your web developer needs to add these security headers to your website's configuration - 
        it's like installing safety features that are available but not turned on by default.
        """
        
        return explanations
    
    def _load_vulnerability_knowledge_base(self) -> Dict[str, Any]:
        """Load vulnerability knowledge base for enhanced analysis"""
        # This would typically load from a file or database
        # For now, we'll create a simplified knowledge base
        kb = {
            'cve_database': {},
            'exploit_patterns': {},
            'remediation_templates': {},
            'business_impact_rules': {}
        }
        
        return kb
    
    def generate_executive_summary(self, analysis_results: Dict) -> str:
        """Generate an executive summary of the security assessment"""
        risk_assessment = analysis_results.get('risk_assessment', {})
        vuln_summary = analysis_results.get('vulnerability_summary', {})
        
        risk_level = risk_assessment.get('risk_level', 'Unknown')
        risk_score = risk_assessment.get('risk_score', 0)
        total_vulns = vuln_summary.get('total_vulnerabilities', 0)
        critical_vulns = vuln_summary.get('by_severity', {}).get('critical', 0)
        high_vulns = vuln_summary.get('by_severity', {}).get('high', 0)
        
        summary = f"""
        EXECUTIVE SECURITY ASSESSMENT SUMMARY
        
        Overall Risk Level: {risk_level} (Score: {risk_score}/100)
        
        Key Findings:
        • Total vulnerabilities identified: {total_vulns}
        • Critical severity issues: {critical_vulns}
        • High severity issues: {high_vulns}
        
        Immediate Actions Required:
        """
        
        if critical_vulns > 0:
            summary += f"• Address {critical_vulns} critical vulnerabilities immediately\n"
        if high_vulns > 0:
            summary += f"• Prioritize resolution of {high_vulns} high-severity issues\n"
        
        summary += """
        • Implement regular security monitoring
        • Establish incident response procedures
        • Consider engaging security professionals for remediation
        
        This assessment provides a snapshot of your current security posture. 
        Regular assessments are recommended to maintain security over time.
        """
        
        return summary